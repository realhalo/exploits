/* [DUMPFD: system tool -- version 1.1 ] *************************************
 * system tool based on dumpenv.c, something made briefly before this.       * 
 * dumps all process file descriptors to stdin.                              *
 *                                                                           *
 * AUTHOR:                                                                   *
 *  v9/vade79@realhalo.org, realhalo.org.                                    *
 *                                                                           *
 * dumpfd.c: program source code to dumpfd, for linux.     (130l!262w!3681b) *
 *****************************************************************************/
#include <stdio.h>
#include <unistd.h>
#include <sys/stat.h>
#include <glob.h>
#include <pwd.h>
#include <grp.h>
int total=0;
char id[]="$Id: dumpfd.c,v 1.1 2001/04/05 20:22:21 EST vade79 Exp $";
int main(){
 int i=0;
 glob_t gb;
 setuid(geteuid());
 if(getuid())
  printe("dumpfd must run as root to process correctly",1);
 gb.gl_offs=1;
 glob("/proc/*",0,0,&gb);
 while(gb.gl_pathc>i){
 if(atoi((char *)basename(gb.gl_pathv[i]))
 ||!strcmp((char *)basename(gb.gl_pathv[i]),"0"))
  getfd((char *)basename(gb.gl_pathv[i]));
  i++;
 }
 globfree(&gb);
 printf("total fd count: %d.\n",total);
 exit(0);
}
int getfd(char *pid){
 int i=0;
 int chr=0;
 char fddir[12+strlen(pid)];
 char cmdfile[15+strlen(pid)];
 char cmd[256];
 char ln[4096];
 char filetype[5];
 char owner[8];
 char group[8];
 FILE *fd;
 struct stat mod;
 struct passwd *pwd;
 struct group *grp;
 glob_t gbfd;
 sprintf(fddir,"/proc/%s/fd/*",pid);  
 sprintf(cmdfile,"/proc/%s/cmdline",pid);
 if(!(fd=fopen(cmdfile,"r")))
  printe("command line of the pid doesn't exist or isn't readable",0);
 else{
  bzero(cmd,sizeof(cmd));
  while((chr=fgetc(fd))!=0x0&&chr!=0x20&&chr!=EOF)
   if(isprint(chr))
    if(i<sizeof(cmd))
     cmd[i++]=chr;
 }
 fclose(fd);
 if(!strlen(cmd)){
  bzero(cmd,sizeof(cmd));
  sprintf(cmd,"UNKNOWN");
 }
 else 
  cmd[i]=0x0;
 gbfd.gl_offs=1;
 switch(glob(fddir,0,0,&gbfd)){
  case 1:
   printe("getfd(): glob had a memory error",0);
   break;
  case 2:
   printe("getfd(): glob had a read error",0);
   break;
 }
 if(!gbfd.gl_pathc)
  printf("*%c%s%c%.7s%c%.7s%c%.7s <no file descriptors currently in use>\n",
  0x9,pid,0x9,owner,0x9,group,0x9,basename(cmd));
 for(i=0;gbfd.gl_pathc>i;i++){
  stat(gbfd.gl_pathv[i],&mod);
  if(!(pwd=getpwuid(mod.st_uid)))
   sprintf(owner,"%u",mod.st_uid);
  else{
   if(strlen(pwd->pw_name))
    sprintf(owner,"%.7s",pwd->pw_name);
   else
    sprintf(owner,"%u",pwd->pw_uid);
  }
  if(!(grp=getgrgid(mod.st_gid)))
   sprintf(group,"%u",mod.st_gid);
  else{
   if(strlen(pwd->pw_name))
    sprintf(group,"%.7s",grp->gr_name);
   else
    sprintf(group,"%u",grp->gr_gid);
  }
  bzero(ln,sizeof(ln));
  if(!readlink(gbfd.gl_pathv[i],ln,sizeof(ln)))
   sprintf(ln,"UNKNOWN");
  if(S_ISREG(mod.st_mode))
   sprintf(filetype,"file");
  else if(S_ISLNK(mod.st_mode))
   sprintf(filetype,"link");
  else if(S_ISDIR(mod.st_mode))
   sprintf(filetype,"dir");
  else if(S_ISCHR(mod.st_mode))
   sprintf(filetype,"cdev");
  else if(S_ISBLK(mod.st_mode))
   sprintf(filetype,"bdev");
  else if(S_ISFIFO(mod.st_mode))
   sprintf(filetype,"fifo");
  else if(S_ISSOCK(mod.st_mode))
   sprintf(filetype,"sock");
  else
   sprintf(filetype,"none");
  total++;
  printf("%d%c%s%c%.7s%c%.7s%c%.7s%c%s%c%s%c%.24s\n",total,0x9,pid,0x9,owner,
  0x9,group,0x9,basename(cmd),0x9,basename(gbfd.gl_pathv[i]),0x9,filetype,0x9,
  strlen(ln)?ln:"UNKNOWN");
 }
 globfree(&gbfd);
 return(0);
}
int printe(char *err,int quit){
 printf("error: %s.\n",err);
 if(quit)
  exit(1);
}
